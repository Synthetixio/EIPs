---
sip: 156
title: Chainlink Debt Pool Oracle
status: Draft
author: Kain Warwick (@Kaiynne), Anton Jurisevic (@zyzek)
discussions-to: https://research.synthetix.io

created: 2021-07-05
---


## Simple Summary
<!--"If you can't explain it simply, you don't understand it well enough." Simply describe the outcome the proposed changes intends to achieve. This should be non-technical and accessible to a casual community member.-->

This SIP proposes to replace the existing debt cache mechanism with a debt pool oracle operated by Chainlink.

## Abstract
This SIP will deprecate the existing debt cache mechanism described in SIPs [83](https://sips.synthetix.io/sips/sip-83)
and [91](https://sips.synthetix.io/sips/sip-91) in favour of an Oracle that reads the
composition of the debt pool, then calculates the total debt size
off-chain and pushes it on-chain via a Chainlink aggregation contract.

The current debt cache mechanism has the benefit of being entirely on-chain, however, it introduces some
complexity to the protocol. By replacing it with a Chainlink oracle we will simplify several functions and reduce gas costs,
as well as introducing more scalability to the number of Synths the protocol can support.

## Motivation
<!--This is the problem statement. This is the *why* of the SIP. It should clearly explain *why* the current state of the protocol is inadequate.  It is critical that you explain *why* the change is needed, if the SIP proposes changing how something is calculated, you must address *why* the current calculation is innaccurate or wrong. This is not the place to describe how the SIP will address the issue!-->
The current debt cache, while an extremely elegant solution to the problem of calculating the size of the debt pool for use by the minting and burning functions has a number of limitations. The primary limitation driving this proposed change is the upcoming need to unify the debt pools across L1 and L2. This requirement would mean that cross chain messaging would need to be enabled and would introduce further complexity to the implementation.
Moving this functionality off-chain will allow for a more scalable network as the number of Synths that can comprise the debt pool will no longer be limited by on-chain computational resources.

## Specification
<!--The specification should describe the syntax and semantics of any new feature, there are five sections
1. Overview
2. Rationale
3. Technical Specification
4. Test Cases
5. Configurable Values
-->

### Overview
<!--This is a high level overview of *how* the SIP will solve the problem. The overview should clearly describe how the new feature will be implemented.-->

1. Implement new interfaces on all Synths and loans to allow the oracle to read and calculate the skew of each Synth
2. Replace the function to read the debt cache with a new function to read the latest debt oracle value
3. Add a function to minting and burning that tracks the incremental debt since the last debt oracle round id
4. Add functinality to track and compare the round id and net off the incremental debt if the debt oracle round id is greater than the last mint/burn round id
5. At the time of deployment increment the debt register of both debt pools with the additional debt to ensure that the debt percentages of stakers relfects the merged debt pools.

### Rationale
<!--This is where you explain the reasoning behind how you propose to solve the problem. Why did you propose to implement the change in this way, what were the considerations and trade-offs. The rationale fleshes out what motivated the design and why particular design decisions were made. It should describe alternate designs that were considered and related work. The rationale may also provide evidence of consensus within the community, and should discuss important objections or concerns raised during discussion.-->
We initially contemplated extending the current debt cache mechanism to support cross network
messaging as well as making a number of other iterative improvements to the calculations.
However, after reviewing the implementation effort compared to performing these calculations off-chain we believed that
an oracle was the optimal solution.
While an oracle increases the reliance on off-chain data aggregation,
the fact that this data is being read on-chain and then processed reduces
some of the failure modes and therefore risk to this change.
It is also possible to make changes to the interfaces at a contract level that feed
up to the oracle to ensure that there are no modifications to the oracle logic to support new protocol functionality. 

### Technical Specification
<!--The technical specification should outline the public API of the changes proposed. That is, changes to any of the interfaces Synthetix currently exposes or the creations of new ones.-->

The rollout of this SIP should occur in several phases in order to
ensure the smoothest and most rapid transition to the oracle-based solution.

#### Phase 1: Basic Debt Pool Oracle 

In this phase, the current debt logic will simply be handed over to a Chainlink oracle.

At this time, as the interface between L1 and L2 is to be unified, `DebtCache` and `BaseDebtCache`
should be merged into a single contract now renamed `DebtPool`.
Only the following external function will need to be retained within the debt pool contract's interface:

* `function currentDebt() external view returns (uint debt, bool anyRateIsInvalid)`

Everything not required by this function can be deleted.

The oracle should simply report the current value returned by `DebtCache.currentDebt()`,
ensuring that the oracle update its result whenever a deviation of at most 1% from
the true value is detected.

An invalid result reporting from the `currentDebt` function should yield an invalid
result reported from the oracle for the system debt.

To the debt pool contract's interface, a single new function should be added,
which will report the debt as received from the oracle.

* `function oracleDebt() external view returns (uint debt, bool isInvalid)`

This function should replace calls in the existing contracts to `debtCache.cacheInfo()`;
in particular, within `Issuer._totalIssuedSynths()`.

This function should report the latest result from the oracle, and its validity, with the caveat that,
as synths are minted and burnt between oracle updates, it must reflect the resulting fluctuations 
in the debt pool. Without this, the issue identified in [SIP-150](https://sips.synthetix.io/sips/sip-150) will remain in place.
To accomplish the desired result, the debt pool contract must track two additional variables:

* `int256 issuanceCorrection`: the net movement in the sUSD value of the debt pool since the last oracle update
* `uint256 lastTimestamp`: the time the Chainlink aggregator last refreshed its reported debt value

With this in mind, the `oracleDebt` function should approximately implement the following pseudo-code:

```solidity
function oracleDebt() external view returns (uint, bool) {

    // Fetch the latest debt number
    (debt, timestamp, isInvalid) = ExchangeRates.debtAndTimestampAndInvalid();

    // An update has occurred, but the new timestamp has not yet been recorded.
    // Do not apply the issuance correction in this case.
    if (lastTimestamp < timestamp) {
        return (debt, isInvalid);
    }

    // Otherwise, account for all mint/burn events
    return (debt + issuanceCorrection, isInvalid);
}
```

In addition, whenever new synths are minted or burnt, whether against SNX or otherwise, the
sUSD value of those synths should be recorded against the `issuanceCorrection` variable:

```solidity
function updateIssuanceCorrection(int amount, bytes32 synth) external onlyIssuers {
    issuanceCorrection += amount * ExchangeRates.getRate(amount);
}
```

This function should fail if the internal rate is invalid. It must be callable only by synth-issuing contracts
including the issuer, wrapper, and multi-collateral contracts. It should be invoked whenever synths
are created or destroyed, but not when exchanged or transformed into another form, such as by deposit into a
futures margin account.

#### Phase 2: Debt Component Disaggregation

Phase 1, although straightforward, still constrains the maximum number of synths possible in the system,
as it is upper bounded by the execution budget of the `currentDebt` function. To alleviate this, the
debt system should be able to break down the debt cache into each of its component parts, representing the
net skew for each synth, including both circulating synths (long) and outstanding non-SNX collateral debt (short).
The overall debt pool value will simply be the sum of all these components.

In this way, Chainlink oracle nodes will just need to perform an off-chain sum over all available synth
debt components. The debt pool contract will require several new functions to support this:

* `function availableDebtComponents() external view returns (bytes32[] memory)`: Returns the list of all available debt component currency keys (`sUSD`, `sETH`, et cetera)
* `function debtComponent(bytes32 key) external view returns (int component, bool invalid)`: Returns the dollar value of a given component of the debt pool. This value will be positive if the debt component is long-skewed, negative if it is short-skewed.

Each debt component will be calculated as follows:

```solidity
function debtComponent(bytes32 key) external view returns (int component, bool invalid) {
    (uint rate, bool invalid) = ExchangeRates.getRateAndInvalid(key);
    
    // The circulating supply is the long part of the debt component
    uint component = synth(key).totalSupply();

    // Any non-SNX backed debt is the short part of the debt component
    // Multicollateral loans
    component -= collateralManager.long(key) + collateralManager.long(short);
    // Any wrapper debt contributing to this component
    component -= wrapper(key);

    return (component * rate, invalid);
}
```

Note that we have omitted the `EtherCollateral` and `EtherCollateralsUSD` contributions present in the current
implementation, as these are shortly to be deprecated.

The Chainlink oracle should report the sum of the debt components in a manner equivalent to the following
function:

```javascript
// Implemented off-chain
function systemDebt() {
    debt = 0;
    invalid = false;

    for (key of DebtPool.availableDebtComponents()) {
        component, componentInvalid = DebtPool.debtComponent(key);
        debt += component;
        invalid |= componentInvalid;
    }

    return (debt, invalid);
}
```

In this way, Synthetix will be able to update the composition of its debt pool by altering the available
debt components, and by changing the behaviour of the `debtComponent` function, without Chainlink nodes
needing to update their internal logic. Each debt component will at first correspond to a particular synth,
but in the future may be extended to different objects.

#### Phase 3: L1/L2 Debt Coalescence

The first phases aim only at converting the isolated debt pools on L1 and L2 to use an oracle.
However, before synths can transit freely between the chains, their debt pools must be unified.

At this stage, the Chainlink oracles must aggregate all debt across chains into a single number
for staking balances and c-ratios to be computed against. For example:

```javascript
// The L1 version of the cross-chain system debt function. 
function systemDebt() {
    l1debt, l1Invalid = systemDebt_L1();
    l2debt, l2Invalid = systemDebt_L2();
    return (l1debt + l2debt, l2Invalid || l1Invalid);
}
```

The `systemDebt_L1()` and `systemDebt_L2()` functions are as defined in phase 2, but simply query
the relevant debt pool contract on each chain.
Be aware that, as synths can move between chains, the debt contribution of a single chain could potentially
be negative.

This new oracle should then be launched to run concurrently with the old one for a time.
Then, in order to merge the pools, the following steps should be performed atomically (where possible):

1. Ensure the target issuance ratio on each chain is identical.
2. Add new debt ledger entries on each chain, to recording the new incoming debt from the other chain.
3. Cut over to the new debt oracle aggregator address.

On each chain, the new debt ledger entry will be updated as if the total debt on the opposing chain
was suddenly issued from a new wallet, as per the logic within `Issuer._addToDebtRegister()`.
Its value will be computed as follows:

`state.lastDebtLedgerEntry() * (1 - (otherChainDebt / (thisChainDebt + otherChainDebt))`

Adding new debt ledger entries will require taking control of `SynthetixState` and calling the
`appendDebtLedgerValue` function directly.

Once these steps have been completed, both chains will share in a common debt pool, and teleporting
synths between the individual debt pools may be enabled.

### Test Cases
<!--Test cases for an implementation are mandatory for SIPs but can be included with the implementation..-->

TBD

### Configurable Values (Via SCCP)
<!--Please list all values configurable via SCCP under this implementation.-->

TBD

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
