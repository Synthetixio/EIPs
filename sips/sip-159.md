---
sip: 159
title: Cross-chain Debt Pool Unification
status: Draft
author: Anton Jurisevic (@zyzek)
discussions-to: https://research.synthetix.io

created: 2021-07-09
requires (*optional): 156
---

## Simple Summary
<!--"If you can't explain it simply, you don't understand it well enough." Simply describe the outcome the proposed changes intends to achieve. This should be non-technical and accessible to a casual community member.-->

This SIP seeks to merge the debt pools between L1 and L2, tracking the total synth debt with a common oracle.

## Abstract

**WARNING:** This proposal is broken. See the knock-on effects section below.

Once [SIP 156](https://sips.synthetix.io/sips/sip-156) has been implemented, each chain will have its own
isolated debt pool. In order to actually allow synths to be teleported between these two chains,
we must ensure that debt is tracking properly across them.

Merging the debt pool across chains is relatively straightforward; the debt oracle
will simply need to add together the debt from each chain. On-chain, it will be necessary
to update the target c-ratios to be identical, and then perform a synchronised cut-over to the new
oracle along with debt ledger updates to account for the new supply each chain is now aware of.

## Motivation
<!--This is the problem statement. This is the *why* of the SIP. It should clearly explain *why* the current state of the protocol is inadequate.  It is critical that you explain *why* the change is needed, if the SIP proposes changing how something is calculated, you must address *why* the current calculation is innaccurate or wrong. This is not the place to describe how the SIP will address the issue!-->

Merging the debt pools is necessary in order to allow synths to be transported freely and fungibly between
multiple chains.
There are additional use-cases that could be imagined, such as using the overall debt fraction
of an individual chain to determine its share of the total inflationary supply, and let stakers choose
the chain they want to sit on.

## Specification
<!--The specification should describe the syntax and semantics of any new feature, there are five sections
1. Overview
2. Rationale
3. Technical Specification
4. Test Cases
5. Configurable Values
-->

### Overview

The Chainlink oracle must monitor the debt composition across multiple chains, and simultaneously push updates to
the aggregated debt number to all of those chains.

To transition to this shared debt pool model, the current L1 and L2 chains must be brought in sync by ensuring
the target c-ratio is identical between chains, and each debt ledger is updated to ensure that
staker debt balances properly account for the newly-merged debt value.

### Rationale

Although it would have been possible to transmit debt updates whenever synths are transferred between
layers, this is a substantial increment in complexity relative to using the oracle directly.
Given the establishment of a debt oracle as of [SIP 156](https://sips.synthetix.io/sips/sip-156),
it is straightforward to leverage this new structure to support a unified debt pool.

### Technical Specification
<!--The technical specification should outline the public API of the changes proposed. That is, changes to any of the interfaces Synthetix currently exposes or the creations of new ones.-->

[SIP 156](https://sips.synthetix.io/sips/sip-156) only aimed at converting the isolated
debt pools on L1 and L2 to use an oracle. However, before synths can transit freely between the chains,
their debt pools must be combined.

#### Cross-Chain Debt Calculation 

In order to do this, the Chainlink oracle must aggregate all debt across chains into a single number
for staking balances and c-ratios to be computed against. For example:

```javascript
// Implemented off-chain
function systemDebt(chain, allChains) {
    totalDebt = 0;
    anyInvalid = false;
    
    for (_chain of allChains) {
        chainDebt, chainInvalid = _chain.systemDebt();
        totalDebt += chainDebt;
        anyInvalid |= chainInvalid;
    }
    
    return (totalDebt, anyInvalid, chain.systemDebt());
}
```

The `_chain.systemDebt()` function corresponds to the sums over all debt components
on a particular chain, as described in SIP-156. The logic here does not differ between chains,
but simply queries the relevant debt pool contract on each layer. This function is described
so that it is straightforward to add additional chains to the system.

Be aware that, as synths will eventually move between chains,
the aggregate debt contribution of a single chain could potentially be negative.
Note also that this function returns both the overall system debt, along with
the individual system debt for a particular chain. That is, each chain should be
aware of its own debt and validity status. The interface of the `DebtPool` contract must be updated
to reflect this.

It will also be important that the debt number is updated **simultaneously** across all chains.
That is, the very same oracle must be responsible for sending the exact same debt number to all chains
at the same time, to minimise front minting style risks associated with distinct debt numbers existing
on chains between which synths can communicate.

#### Coalescence Procedure

The new debt oracle should be launched to run concurrently with the old one for a time.
Then, in order to merge the pools, the following steps should be performed atomically (where possible):

1. Ensure the target issuance ratio on each chain is identical.
2. Pause the system.
3. Add new debt ledger entries on each chain, to record the new incoming debt from the other chain.
4. Cut over to the new debt oracle aggregator address.
5. Unpause the system.

On each chain, the value of the new debt ledger entry will be as if the total debt on the opposing chain
was suddenly issued from a new wallet, as per the logic within `Issuer._addToDebtRegister()`.
Its value should be computed as follows:

`state.lastDebtLedgerEntry() * (1 - (otherChainDebt / (thisChainDebt + otherChainDebt))`

Adding new debt ledger entries will require taking control of `SynthetixState` and calling the
`appendDebtLedgerValue` function directly.

Once these steps have been completed, both chains will share in a common debt pool, and teleporting
synths between the individual debt pools can be enabled.

#### Knock-on effects

The main area this will affect is issuance, which must now be restricted to a single chain, as
although the oracle will be able to relay movements in the debt pool size, it does not
take into account transmitting the debt ledger entries that go along with issuance/burning.
We will require substantial rearchitecture to support this. To illustrate this, consider the following schematic
example.

```
t0: One user per layer issues 20% each of the debt on their layer ($10)
=======================================================================
L1 Debt: $50
L1 user debt ledger entry: 1.0
L1 user debt share: 20%

L2 Debt: $50
L2 user debt ledger entry: 1.0
L2 user debt share: 20%

t1: Merge occurs in the equally-sized debt pools
================================================
Total Debt: $100
L1 last debt ledger entry: 0.5
L2 last debt ledger entry: 0.5 

t2: A new user on L1 issues $100 new debt
=========================================
Total Debt: $200
L1 Last Debt Ledger Entry: 0.25
L2 Last Debt Ledger Entry: 0.5

t3: Check the original user's debt balances
============================================================================================
debtBalance = = lastDebtLedgerEntry / userDebtLedgerEntry * userDebtOwnership * totalSystemValue 

L1UserDebt = 0.25 / 1.0 * 0.2 * $200
       = 0.05 * $200 = $10

L2UserDebt = 0.5 / 1.0 * 0.2 * $200
       = 0.2 * $200 = $20
```

So the l1 user has the correct debt, but the L2 user's debt has doubled because although he received
an updated total system debt, no debt ledger entry was added for the issuance event which
increased it. This system will operate fine for fluctuations in the value of the debt pool due
to price movements, but not due to issuance or burning.
So although the initial merge is fine, the debt readings will rapidly fall apart shortly thereafter, unless
all the debt and issuance/burning operations are moved to a single chain; or some other fix is found.

The following areas will require investigation, as they will be affected by the debt pool merger:

* **Governance**: Although users must claim rewards independently on each layer, even if those rewards are accruing to the same 
  wallet address, it will be important to ensure that governance processes respect the newly-combined debt pool, and that 
  vote weights respect the combined weight of a user's staked collateral across all chains.
* **Loans**: The interest rates charged on loans are determined by examining an aggregate skew in the system. It's not 
  clear that this can be computed accurately across two chains. It should be verified that the behaviour of the loans
  contracts only examine the skew on their own chain, not involving the full cross-chain debt
  if it is impossible to properly account for it.

### Test Cases
<!--Test cases for an implementation are mandatory for SIPs but can be included with the implementation..-->

TBD

### Configurable Values (Via SCCP)
<!--Please list all values configurable via SCCP under this implementation.-->

N/A

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
